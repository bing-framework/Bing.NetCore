using System.Diagnostics;
using System.Text;
using Bing.Analyzers.SourceGenerator;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Bing.Analyzers;

[Generator]
public class ChangeTrackableSourceGenerator : ISourceGenerator
{
    /// <summary>
    /// 初始化
    /// </summary>
    /// <param name="context">上下文</param>
    /// <exception cref="NotImplementedException"></exception>
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new DomainObjectBaseSyntaxReceiver());
    }

    /// <summary>
    /// 执行
    /// </summary>
    /// <param name="context">上下文</param>
    public void Execute(GeneratorExecutionContext context)
    {
        var log = new StringBuilder();
        log.AppendLine($"// <auto-generated time='{DateTimeOffset.Now:yyyy-MM-dd HH:mm:ss}' />");
        if (context.SyntaxReceiver is not DomainObjectBaseSyntaxReceiver receiver)
        {
            log.Append("// warning: ").AppendLine("The count of detected class is zero");
        }
        else
        {
            var domainBaseSymbol = context.Compilation.GetTypeByMetadataName("Bing.Domain.Entities.DomainObjectBase`1");
            foreach (var classDecl in receiver.CandidateClasses)
            {
                var semanticModel = context.Compilation.GetSemanticModel(classDecl.SyntaxTree);
                if (ModelExtensions.GetDeclaredSymbol(semanticModel, classDecl) is not INamedTypeSymbol classSymbol)
                    continue;
                var inheritsDomainBase = false;
                for (var baseType = classSymbol.BaseType; baseType != null; baseType = baseType.BaseType)
                {
                    if (domainBaseSymbol != null)
                    {
                        if (SymbolEqualityComparer.Default.Equals(baseType.OriginalDefinition, domainBaseSymbol))
                        {
                            inheritsDomainBase = true;
                            break;
                        }
                    }
                    else
                    {
                        if (baseType.Name == "DomainObjectBase")
                        {
                            inheritsDomainBase = true;
                            break;
                        }
                    }
                }
                if (!inheritsDomainBase)
                    continue;
                if (!classDecl.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword)))
                    continue;
                var namespaceName = classSymbol.ContainingNamespace.IsGlobalNamespace
                    ? string.Empty
                    : classSymbol.ContainingNamespace.ToDisplayString();
                var className = classSymbol.Name;
                var typeParams = classDecl.TypeParameterList?.ToFullString() ?? string.Empty;
                var typeConstraints = classDecl.ConstraintClauses.Count > 0
                    ? " " + string.Join(" ", classDecl.ConstraintClauses.Select(c => c.ToString()))
                    : string.Empty;
                var properties = GetProperties(classSymbol);
                GeneratePartialClassAndAddChangesMethod(context, namespaceName, className, typeParams, typeConstraints,
                    properties);
            }

        }
        context.AddSource("Log.1.g.cs", SourceText.From(log.ToString(), Encoding.UTF8));
    }

    /// <summary>
    /// 生成部分类并添加变更方法
    /// </summary>
    /// <param name="context"></param>
    /// <param name="namespaceName"></param>
    /// <param name="className"></param>
    /// <param name="typeParams"></param>
    /// <param name="typeConstraints"></param>
    /// <param name="properties"></param>
    private void GeneratePartialClassAndAddChangesMethod(GeneratorExecutionContext context, string namespaceName, string className, string typeParams, string typeConstraints, List<BuilderPropertyInfo> properties)
    {
        var sourceBuilder = new StringBuilder();
        sourceBuilder.AppendLine($"// <auto-generated time='{DateTimeOffset.Now:yyyy-MM-dd HH:mm:ss} />");
        sourceBuilder.AppendLine("using System;");
        sourceBuilder.AppendLine("using System.Reflection;");
        sourceBuilder.AppendLine("using System.Linq;");
        sourceBuilder.AppendLine();
        if (!string.IsNullOrWhiteSpace(namespaceName))
        {
            sourceBuilder.AppendLine($"namespace {namespaceName};");
        }
        var bodyScript = $$"""
                      public partial class {{className}}
                      {
                          /// <summary>
                          /// 添加变更列表
                          /// </summary>
                          protected override void AddChanges( {{className}} other )
                          {
                              {{properties.Render((p, i) => $$"""
                                                              AddChange( t=> t.{{p.Name}}, other.{{p.Name}} );
                                                              
                                                              """).Ident(2) }}
                          }
                      }
                      """;
        sourceBuilder.AppendLine(bodyScript);
        context.AddSource($"{namespaceName}.{className}.AddChanges.g.cs", SourceText.From(sourceBuilder.ToString(), Encoding.UTF8));
    }

    struct BuilderPropertyInfo
    {
        public BuilderPropertyInfo(PropertyDeclarationSyntax property) : this()
        {
            IsRequired = property.Modifiers.Any(m => m.ToString() == "required");
            Type = property.Type.ToString();
            Name = property.Identifier.ToString();
            ParameterName = $"{Name[0].ToString().ToLower()}{Name.Remove(0, 1)}";
            BackingFieldName = $"_{ParameterName}";
        }

        public bool IsRequired { get; set; }
        public string Name { get; set; }
        public string Type { get; set; }
        public string ParameterName { get; set; }
        public string BackingFieldName { get; set; }
    }

    private List<BuilderPropertyInfo> GetProperties(INamedTypeSymbol classSymbol)
    {
        var properties = new List<BuilderPropertyInfo>();

        // Traverse current class and base classes
        for (var currentType = classSymbol; currentType != null; currentType = currentType.BaseType)
        {
            var classDecl = currentType.DeclaringSyntaxReferences.FirstOrDefault()?.GetSyntax() as ClassDeclarationSyntax;
            if (classDecl == null)
                continue;

            // Get properties declared in this class
            var classProperties = classDecl.DescendantNodes()
                .OfType<PropertyDeclarationSyntax>()
                .Where(x => x.Modifiers.All(m => m.ToString() != "static")) // Filter out static properties
                .Select(x => new BuilderPropertyInfo(x))
                .ToList();

            properties.AddRange(classProperties); // Add them to the list
        }
        return properties;
    }
}

internal static class Extensions
{
    public static string Ident(this object source, int identLevels)
    {
        var lines = source.ToString().TrimStart(' ').Split('\n');
        var ident = new string(' ', identLevels * 4);
        return string.Join("\n", lines.Select((x, i) => $"""{(i > 0 ? ident : "")}{x}"""));
    }

    public static string Render<T>(this IEnumerable<T> source, Func<T, string> template, string separator = "")
    {
        return string.Join(separator, source.Select(template));
    }

    public static string Render<T>(this IEnumerable<T> source, Func<T, int, string> template, string separator = "")
    {
        return string.Join(separator, source.Select(template));
    }
}
